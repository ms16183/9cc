# 9cc C compiler

[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)を参考にします．

サイト著者のリポジトリは[rui314/9cc](https://github.com/rui314/9cc)です．

# 環境
- WSL Ubuntu 18.04 LTS
- gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0

# 学習事項

## トークナイザ
トークナイザは入力された文字列をトークンという，プログラムの動作として意味のある単位に分割する．

例えば

```
hoge = 10 + 2*4 - (9/3);
```

をトークナイズすると，

```
hoge, =, 10, +, 2, *, 4, -, (, 9, /, 3, ), ;
```

となる(空白は無視)．次に，`hoge`は変数，`10`や`2`は数値，`=`は代入を行う記号，`+`や`*`は二項演算子，`;`は終端記号と識別子を付与する．

## 構文解析器
構文解析器は，トークンを基に，どのように計算すればよいのかを解析する．先ほどの例を構文解析器で解析すると，

```
hoge = 10 + 2*4 - (9/3);
```

1. `9/3`を計算する．結果は`3`．
1. `2*4`を計算する．結果は`8`．
1. `8-3`を計算する．結果は`5`．
1. `10+5`を計算する．結果は`15`．
1. `=`により，`hoge`に代入を行う．
1. `;`によりこの式の計算を終了する．

のように計算順序を作成し，リストや配列に保存する．構文解析の方法としては文脈自由文法の1つである，Backs-Naur form(BNF)を用いている．

## BNFによる数式生成

- `<var>` 変数`var`
- `<A> ::= <B>` `A`を`B`と定義する．
- `|` 又は
- `()` 括弧
- `"str"` 文字列`str`
- `*` 直前の文字や変数の0回以上の繰り返し．
- `?` 直前の文字や変数が0回或いは1回出現する．

 ```
<function> ::= <type> <ident> "(" <params>? ")" "{" <stmt>* "}"
<params>   ::= <type> <ident> ("," <type> <ident>)*

<stmt> ::=   "{" <stmt>* "}"
           | "if" "(" <expr> ")" <stmt> ("else" <stmt>)?
           | "while" "(" <expr> ")" <stmt>
           | "for" "(" <expr>? ";" <expr>? ";" <expr>? ")" <stmt>
           | "return" <expr> ";"
           | <declaration> ";"
           | <expr> ";"

<declaration> ::= <type> <ident>("=" <expr>)? ("," <ident>("=" <expr>)?)*
<expr>        ::= <assign>
<assign>      ::= <equality> ("=" <assign>)?
<equality>    ::= <relational> ( "==" <relational> | "!=" <relational>)*
<relational>  ::= <add> ("<" <add> | ">" <add> | "<=" <add> | ">= <add>)*
<add>         ::= <mul> ("+" <mul> | "-" <mul>)*
<mul>         ::= <unary> ("+" <unary> | "-" <unary>)*
<unary>       ::= <primary> | ("+" | "-" | "&" | "*")? <unary>
<primary>     ::= "(" <expr> ")" | <ident> <func-args>? | <num>
<func-args>   ::= "(" (<assign> ("," <assign>)*)? ")"
<num>         ::= <num>? <digit>

<type>     ::= ("int" | "float") "*"?
<ident>       ::= (<alphabet> | "_") (<alphabet> | <digit> | "_")*
<digit>    ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<alphabet> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
```

```
数値が浮動小数点の場合，浮動小数点は
<浮動小数点定義> ::= [<符号>]<小数点定数>[<指数部>]
                    |[<符号>]<数字列><指数部>

<小数点定数> ::= [<数字列>]<.><数字列>|<数字列><.>
<指数部>     ::=<E>[<符号>]<数字列>
<数字列>     ::=<数字>|<数字列><数字>
<数字>       ::= 0|1|2|3|4|5|6|7|8|9
<符号>       ::= +|-

 ```


## コードジェネレータ
コードジェネレータは，構文解析器から得た計算順序を基にアセンブリあるいは機械語をジェネレートする．

例えば

```
1+2;
```

をトークナイズ，構文解析後にコードジェネレータにかけると以下のようになる．

```
.intel_syntax noprefix
.global main

main:
  push rbp
  mov rbp, rsp
  sub rsp, 208
  push 1
  push 2
  pop rdi
  pop rax
  add rax, rdi
  push rax
  pop rax
  mov rsp, rbp
  pop rbp
  ret
```

1. 計算を順序よく行うため，スタックの用意を行う．ここではrbpからrspまで208ビット(=26バイト)の領域を確保している．
1. 構文解析により，1と2という数字を加算することが分かっている．最初に1と2をスタックにpushする．
1. 次に各々の数字をpopし，rdiとraxに格納する．
1. `add`により，加算する．結果はraxに格納されている．
1. 加算結果はスタックにpushされる．
1. スタックの位置は元の位置に戻され，rpbの値をpopする．

のようにコードを作成する．

## 翻訳限界
[C言語の翻訳限界](https://qiita.com/yuki12/items/26994416162b54c811a1)が存在する．
そのため無限のネスト，無限の引数を意識する必要はない．
