# 9cc C compiler

[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)を参考にします．

サイト著者のリポジトリは[rui314/9cc](https://github.com/rui314/9cc)です．

# 環境
- WSL Ubuntu 18.04 LTS
- gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0

# 学習事項

## トークナイザ
トークナイザは入力された文字列をトークンという，プログラムの動作として意味のある単位に分割する．

例えば

```
hoge = 10 + 2*4 - (9/3);
```

をトークナイズすると，

```
hoge, =, 10, +, 2, *, 4, -, (, 9, /, 3, ), ;
```

となる(空白は無視)．次に，`hoge`は変数，`10`や`2`は数値，`=`は代入を行う記号，`+`や`*`は二項演算子，`;`は終端記号と識別子を付与する．

## 構文解析器
構文解析器は，トークンを基に，どのように計算すればよいのかを解析する．先ほどの例を構文解析器で解析すると，

```
hoge = 10 + 2*4 - (9/3);
```

1. `9/3`を計算する．結果は`3`．
1. `2*4`を計算する．結果は`8`．
1. `8-3`を計算する．結果は`5`．
1. `10+5`を計算する．結果は`15`．
1. `=`により，`hoge`に代入を行う．
1. `;`によりこの式の計算を終了する．

のように計算順序を作成し，リストや配列に保存する．構文解析の方法としては文脈自由文法の1つである，Backs-Naur form(BNF)を用いている．

## BNFによる数式生成

- `::=` 定義
- `|` 又は
- `<>` 変数，括弧
- `*` 直前の文字の0回以上の繰り返し
- `?` 直前の文字があってもなくても良い．

以下のBNFでは，比較演算子，括弧，加算，減算，乗算，除算，整数を用いた式を表すことができる．

```
<数式1> ::= <数式2> <( <==|!=> <数式2> )>*
<数式2> ::= <数式3> <( <'<'|'>'|'<='|'=>'> <数式3>)>*
<数式3> ::= <数式4> | <<+|-> <数式4>>*
<数式4> ::= <数式5> | <<*|/> <数式5>>*
<数式5> ::= <+|->? <数式6>
<数式6> ::= <整数>  | ( <数式1> )
```

```
数値が浮動小数点の場合，浮動小数点は
<浮動小数点定義> ::= [<符号>]<小数点定数>[<指数部>]
                    |[<符号>]<数字列><指数部>

<小数点定数> ::= [<数字列>]<.><数字列>|<数字列><.>
<指数部>     ::=<E>[<符号>]<数字列>
<数字列>     ::=<数字>|<数字列><数字>
<数字>       ::= 0|1|2|3|4|5|6|7|8|9
<符号>       ::= +|-

 ```

## コードジェネレータ
コードジェネレータは，構文解析器から得た計算順序を基にアセンブリあるいは機械語をジェネレートする．

例えば

```
1+2;
```

をトークナイズ，構文解析後にコードジェネレータにかけると以下のようになる．

```
.intel_syntax noprefix
.global main

main:
  push rbp
  mov rbp, rsp
  sub rsp, 208
  push 1
  push 2
  pop rdi
  pop rax
  add rax, rdi
  push rax
  pop rax
  mov rsp, rbp
  pop rbp
  ret
```

1. 計算を順序よく行うため，スタックの用意を行う．ここではrbpからrspまで208ビット(=26バイト)の領域を確保している．
1. 構文解析により，1と2という数字を加算することが分かっている．最初に1と2をスタックにpushする．
1. 次に各々の数字をpopし，rdiとraxに格納する．
1. `add`により，加算する．結果はraxに格納されている．
1. 加算結果はスタックにpushされる．
1. スタックの位置は元の位置に戻され，rpbの値をpopする．

のようにコードを作成する．
